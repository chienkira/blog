<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chienkira</title>
    <link>https://chienkira.github.io/blog/</link>
    <description>Recent content on Chienkira</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 23 Feb 2019 16:42:28 +0900</lastBuildDate>
    
	<atom:link href="https://chienkira.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Học Bằng Lái Xe Oto Ở Nhật</title>
      <link>https://chienkira.github.io/blog/posts/h%E1%BB%8Dc-b%E1%BA%B1ng-l%C3%A1i-xe-oto-%E1%BB%9F-nh%E1%BA%ADt/</link>
      <pubDate>Sat, 23 Feb 2019 16:42:28 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/h%E1%BB%8Dc-b%E1%BA%B1ng-l%C3%A1i-xe-oto-%E1%BB%9F-nh%E1%BA%ADt/</guid>
      <description>Mình mới lấy xong bằng lái oto ở Nhật (thực ra là lấy được 1 tháng rồi 😄), nhận ra có nhiều thông tin hữu ích có thể chia sẻ với ai đó đang cũng có ý định học nên chờ gì nữa nhỉ viết bài này thôi.
↓↓↓ Ảnh khu vực học thực hành lái ở trong trường ↓↓↓   View this post on Instagram         A post shared by Kira Chien (@chienkira) on Jan 10, 2019 at 9:32pm PST</description>
    </item>
    
    <item>
      <title>Tất Tần Tật Về Cloudfront</title>
      <link>https://chienkira.github.io/blog/posts/t%E1%BA%A5t-t%E1%BA%A7n-t%E1%BA%ADt-v%E1%BB%81-cloudfront/</link>
      <pubDate>Thu, 21 Feb 2019 16:33:07 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/t%E1%BA%A5t-t%E1%BA%A7n-t%E1%BA%ADt-v%E1%BB%81-cloudfront/</guid>
      <description>CloudFrontとは  AWSが提供するCDN（コンテンツ配信サービス）である。 世界中に設置されているエッジサーバを利用し、ユーザの最寄りエッジサーバからキャッシュを送ることでユーザへ高速な配信を実現できるサービスである。  CloudFrontの設定 Distribution Settings（ディストリビューション設定） ディストリビューションはCloudFrontの配信設定の単位になるので、CloudFrontの使用にはまずディストリビューションを作成する必要がある。
ディストリビューション配信種類はWebとRTMPがある。 - Web: ウェブ配信専用（基本的にこちらの種類を使う） - RTMP: メディアのストリーミング配信専用
 Alternate Domain Names (CNAMEs) CloudFront によって割り当てられたドメイン名（例 https://hogehoge.cloudfront.net）の代わりに、使用したい代替ドメイン名（例 https://example.com）をここに指定する。
 SSL Certificate デフォルトのCloudFrontのSSL証明書を使用するか、独自SSL証明書（ACMで登録したもの）を選択する。
  Origin Settings（オリジンドメイン設定）  Origin Domain Name
オリジンドメインを選択する。 フロントエンドをS3バケットに格納した場合は、オリジンドメインにS3バケットを選択すると良い。
※オリジンドメインとは、コンテンツの提供元のことを表す。オリジンドメインには、AWSのリソース（S3バケットやELBやAWS MediaPackageエンドポイントや AWS MediaStoreContainerエンドポイント）か、もしくはそれ以外のリソース（どこかのウェブサーバのドメイン等）でも指定できる。
 Origin Path オリジン内のディレクトリからコンテンツが配信されるようにしたい場合は、オリジンパスを入力することで実現できる。 例えば、オリジンパスに/greenを入力した場合、ユーザーがブラウザでexample.com/index.htmlとリクエストすると、CloudFrontは s3bucket/green/index.html を返答する。
 Origin ID ディストリビューション内でこのオリジンをユニークで区別する為の文字列である。 オリジンドメインを入力したら、自動的に生成されるオリジンIDをそのまま使っても良い。
 Restrict Bucket Access CloudFrontのURLでしかS3バケット内のコンテンツがアクセスできないように制御をしたい場合、この設定をYESにする。 ユーザーがCloudFrontのURLでもS3バケットのURLでもアクセスできるようにしたい場合は、[No]にする。
 Origin Access Identity [Restrict Bucket Access] で [Yes] にした場合、オリジンアクセスアイデンティティが必要になる。 新しいアイデンティティを作成するか、既存のアイデンティティを使用するかを下の [Your Identities] 設定項目で選択する。</description>
    </item>
    
    <item>
      <title>&#34;Thông&#34; Mạng Cho Aws SAM Và Dynamodb Local</title>
      <link>https://chienkira.github.io/blog/posts/th%C3%B4ng-m%E1%BA%A1ng-cho-aws-sam-v%C3%A0-dynamodb-local/</link>
      <pubDate>Wed, 13 Feb 2019 15:50:07 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/th%C3%B4ng-m%E1%BA%A1ng-cho-aws-sam-v%C3%A0-dynamodb-local/</guid>
      <description>Dynamodb localを使いローカルで開発時 SAM localのstart-apiやinvokeコマンドを使い、Lambda関数をローカルで実行する時は、
- Lambda関数がSAMのDockerコンテナ上で実行され - Dynamodb localが別のDockerコンテナ上で動く
そのため、Lambda関数がDynamodb localへアクセルできるように、 2つのDockerコンテナを同じネットワークに繋がせる必要があります。
対応方法は以下の通りです。
まずはDynamodb localのDockerセットアップ file: docker-compose.yml
services: dynamodb: container_name: dynamodb #重要：コンテナ名を指定 image: amazon/dynamodb-local networks: - aws_local_network #繋がるネットワークを指定 &amp;lt;省略&amp;gt; networks: aws_local_network: name: aws_local_network #重要：ネットワーク名を強制的に指定 そして、モデルのソースコードを以下のように修正
if os.environ.get(&amp;#39;AWS_SESSION_TOKEN&amp;#39;) is None: host = &amp;#34;http://dynamodb:8000&amp;#34; 　解説： AWS_SESSION_TOKEN 環境変数には、実際のAWS環境で実行する時にしか値がないので
ローカルで実行しているかどうなの判別に使えます。
また、http://dynamodb:8000のdynamodbはDynamodb localのコンテナ名です。
最後に、Lambda関数をローカルで実行する時 --docker-network aws_local_network を追加で指定
sam local start-api --docker-network aws_local_network
又は、sam local invoke HogeFunction -e event.json --docker-network aws_local_network</description>
    </item>
    
    <item>
      <title>Cơ Bản Về Api Gateway</title>
      <link>https://chienkira.github.io/blog/posts/c%C6%A1-b%E1%BA%A3n-v%E1%BB%81-api-gateway/</link>
      <pubDate>Tue, 12 Feb 2019 15:45:04 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/c%C6%A1-b%E1%BA%A3n-v%E1%BB%81-api-gateway/</guid>
      <description>API GatewayとLambda間の処理フロー APIGatewayとLambda間の処理フローは以下の図の通りです。  クライアントからHTTPリクエストがきた時に、[Method request] がそのリクエストを受け取って認証などを行う API Gatewayは必要に応じて [Integration Request]を使い、リクエストのデータを変換してから、Lambdaに転送する ※ 変換されたデータがLambda関数のevent変数に入ります。 次にAPI Gatewayは [Integration Response] を使い、Lambdaから返ってきた戻り値（処理結果）をまたデータ変換をしてから、[Method Response] に転送 最後に、API Gatewayが [Method Response]にてクライアントに返信する  → Integration Request と Integration Responseのデータ変換に関しては、以下の2選択肢があります。
 ①AWSのLambda proxy integration（Lambda プロキシ統合）に任せるか ②データ変換に使われるマッピングテンプレートを自分で定義するか  Lambda proxy integration（Lambda プロキシ統合） AWSのLambda プロキシ統合の詳細説明 Lambda プロキシ統合を使用する場合、Lambda関数へのInputデータやLambda関数のOutputデータのフォーマットが決まってます。
Lambda 関数の入力形式 以下のようにHTTPリクエスト全体をLambda 関数のevent変数にマッピングされます。 よく使うのは：
 headers: リクエストのヘッダデータ httpMethod: リクエストのメソッド情報 pathParameters: GETリクエストのパスパラメータ 例）/hoge/{group}/{user}のようなリクエストの場合、pathParameters には、groupとuserが入ってきます。 queryStringParameters: GETリクエストのクエリパラメータ 例）/hoge/{user}?page=5のようなリクエストの場合、queryStringParameters には、pageが入ってきます。 body: POSTリクエストのPostデータ  { &amp;#34;resource&amp;#34;: &amp;#34;Resource path&amp;#34;, &amp;#34;path&amp;#34;: &amp;#34;Path parameter&amp;#34;, &amp;#34;httpMethod&amp;#34;: &amp;#34;Incoming request&amp;#39;s method name&amp;#34; &amp;#34;headers&amp;#34;: {String containing incoming request headers} &amp;#34;multiValueHeaders&amp;#34;: {List of strings containing incoming request headers} &amp;#34;queryStringParameters&amp;#34;: {query string parameters } &amp;#34;multiValueQueryStringParameters&amp;#34;: {List of query string parameters} &amp;#34;pathParameters&amp;#34;: {path parameters} &amp;#34;stageVariables&amp;#34;: {Applicable stage variables} &amp;#34;requestContext&amp;#34;: {Request context, including authorizer-returned key-value pairs} &amp;#34;body&amp;#34;: &amp;#34;A JSON string of the request payload.</description>
    </item>
    
    <item>
      <title>Tips Cài Đặt Pycharm Để Code Python</title>
      <link>https://chienkira.github.io/blog/posts/tips-c%C3%A0i-%C4%91%E1%BA%B7t-pycharm-%C4%91%E1%BB%83-code-python/</link>
      <pubDate>Fri, 08 Feb 2019 15:49:01 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/tips-c%C3%A0i-%C4%91%E1%BA%B7t-pycharm-%C4%91%E1%BB%83-code-python/</guid>
      <description>PycharmのInterpreterの設定方法 python仮想環境を使い、開発する際にはPycharmがそのpython仮想環境を認識させる必要があります。
※ 認識させないと、Pycharmの方がインストールされているライブラリが分からずimportのエラーなどが出てしまいます。
 ① Python仮想環境の場所を確認
pipenvの場合はこのコマンドで確認できます。 pipenv --venv
output例： /Users/kira/.local/share/virtualenvs/project_name-Qr43IEm2
 ② Pycharmの方でプロジェクトのInterpreterを設定
 PycharmのPreferences画面を開く
 左側のメニューから「Project: プロジェクト名」=&amp;gt;「Project Interpreter」を選択
 Project Interpreterのドロップダウンから「Show All」を選択し、「+」の追加ボタンを押す
 左側のメニューから「System Interpreter」を選択し、「&amp;hellip;」ボタンをクリックして①で確認できたパスを指定
※ 注意：bin/pythonX.Xまで指定してください。   PycharmのSources Root設定方法 開発ソースコードがプロジェクトの直下にはなく、srcフォルダーなどの中に置かれる場合が多いです。
※ CodeUriが./srcで設定される場合が多いです。
例えば以下のようなファイル構成の場合
|--template.yaml |--src | |--app | | |--__init__.py | | |--common | | | |--__init__.py | | | |--helper.py | | |--handlers | | | |--__init__.py | | | |--purchase.py purchase.pyファイルでapp/common/helper.pyのモジュールなどをimportするところのfrom app.common.helper import some_helper にPycharmがエラーを表示します。</description>
    </item>
    
  </channel>
</rss>