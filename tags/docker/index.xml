<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>docker on Chienkira full stack web developer</title>
    <link>https://chienkira.github.io/blog/tags/docker/</link>
    <description>Recent content in docker on Chienkira full stack web developer</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 09 Jan 2020 17:50:27 +0900</lastBuildDate>
    
	<atom:link href="https://chienkira.github.io/blog/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Memo about AWS ECS Fargate</title>
      <link>https://chienkira.github.io/blog/posts/ecs-fargate/</link>
      <pubDate>Thu, 09 Jan 2020 17:50:27 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/ecs-fargate/</guid>
      <description>Mới đầu năm 2020 nhưng lại có cơ hội được tham khảo một hệ thống xài docker container vào môi trường prod. Ở đây họ dùng ECS và Fargate của AWS. Mình vẽ lại sơ đồ cấu thành của nó lưu lại làm tham khảo và ôn tập lại ECS luôn.
Cấu thành của 1 hệ thống API dùng ECS Fargate ↓ Ảnh svg, có thể tải về và phóng to ra.</description>
    </item>
    
    <item>
      <title>Set up HTTPS-supported development environment for Rails app</title>
      <link>https://chienkira.github.io/blog/posts/https-cho-m%C3%B4i-tr%C6%B0%E1%BB%9Dng-dev-rails/</link>
      <pubDate>Sun, 18 Aug 2019 21:47:30 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/https-cho-m%C3%B4i-tr%C6%B0%E1%BB%9Dng-dev-rails/</guid>
      <description>Hướng dẫn cấu hình tạo môi trường dev rails hỗ trợ giao thức HTTPS hoàn chỉnh nhanh và đơn giản nhất. Https &amp;ldquo;hiểu đơn giản kiểu đà điểu&amp;rdquo; là giao thức được secured, không trần truồng và lộ liễu như http thông thường.
Tại sao cần HTTPS cho môi trường dev? Đúng rồi! Chắc sẽ có người thắc mắc vậy, &amp;ldquo;Ông dỗi hơi hay sao mà phải tạo môi trường dev hỗ trợ HTTPS, dev thì http là được rồi còn gì?</description>
    </item>
    
    <item>
      <title>Basic knowledge about Kubernetes(日本語)</title>
      <link>https://chienkira.github.io/blog/posts/hi%E1%BB%83u-kh%C3%A1i-ni%E1%BB%87m-c%C6%A1-b%E1%BA%A3n-c%E1%BB%A7a-kubernetes/</link>
      <pubDate>Sat, 08 Jun 2019 11:12:01 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/hi%E1%BB%83u-kh%C3%A1i-ni%E1%BB%87m-c%C6%A1-b%E1%BA%A3n-c%E1%BB%A7a-kubernetes/</guid>
      <description> Kubernetesとは Dockerは開発環境として使うのがすごく便利ですが、本番環境で使うと色々な問題が考えられます。
 コンテナがもし死んだら直ちに検知してコンテナを再起動したりして回復しないといけない リクエストが大量になる時、スケールをしないといけない 複数コンテナがあるなら、ロードバランシングをしないといけない 等々  ↑の問題を解決してくれるのがKubernetesの役割です。
Kubernetes（K8s）はコンテナオーケストレーションシステムです。
 Googleが2014年に公開しました。 Googleの長きにわたるコンテナ運用の知見が詰まっているらしいです。 K8sのメイン機能としては、コンテナ化されたアプリケーションを以下のこと自動的に行うことです。  デプロイ コンテナ管理 スケール   イメージは、K8sがコンテナの管理をいい感じにやってくれるので、 私たちはただK8sに「こんな感じでシステムを運用して」と注文書（マニフェスト）を投げつけるだけです。 それ以外はK8sに任せて良いです。
Kubernetesの構成を理解 クラスター  クラスター本体  ノード  クラスターに属するマシンを表すオブジェクト クラスターには、Masterノード１個と複数Workerノードがある Workerノードは私たちが開発したアプリケーションの実行環境となる（コンテナ群の実行環境） Masterノードは、私たちの命令に従って、各Workerノードにコンテナをデプロイしたりして、いい感じに監視・維持してくれる Masterノードは１つ、Workerノードは複数がある  Pod  Workerノード上に生成されるオブジェクト K8sの最小デプロイ単位であり、スケールする時はPod単位で生成／破棄される Pod内にコンテナが１つ以上ある  ReplicaSet（RS）とDeployment  RS  同じ仕様のPodが指定した数だけ存在するよう生成・管理する 例えば、Podが死んだ時マニフェストで指定した数になるよう自動回復してくれる  Deployment  新しいバージョンのリリースを管理するための仕組み   Service  クラスター内外からのリクエストをPodにルーティングするオブジェクト 複数のPodに対するロードバランシングの役割を持つ  </description>
    </item>
    
    <item>
      <title>What is CI and how to set up CI using Circle CI service</title>
      <link>https://chienkira.github.io/blog/posts/%C3%A1p-d%E1%BB%A5ng-circle-ci/</link>
      <pubDate>Sat, 23 Mar 2019 21:40:43 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/%C3%A1p-d%E1%BB%A5ng-circle-ci/</guid>
      <description>Lúc đầu trang blog này mình định deploy bằng tay vì nó đơn giản, thao tác cũng chẳng có gì - chạy cái shell script xong trong nháy mắt thôi. Nhưng mà tuần này chưa có gì hay ho để viết nên mình quyết định cài đặt CI cho em nó rồi lấy ý để viết bài này giới thiệu về CI luôn.
Giới thiệu CI và Circle CI CI CI viết tắt của Continuous Integration (Tích hợp liên tục) Trong quy trình làm phần mềm, lỗi lầm lớn nhất có thể xảy ra không phải là khi developer code ra cái gì tởm lợm!</description>
    </item>
    
    <item>
      <title>&#34;Thông&#34; Mạng Cho Aws SAM Và Dynamodb Local (日本語)</title>
      <link>https://chienkira.github.io/blog/posts/th%C3%B4ng-m%E1%BA%A1ng-cho-aws-sam-v%C3%A0-dynamodb-local/</link>
      <pubDate>Wed, 13 Feb 2019 15:50:07 +0900</pubDate>
      
      <guid>https://chienkira.github.io/blog/posts/th%C3%B4ng-m%E1%BA%A1ng-cho-aws-sam-v%C3%A0-dynamodb-local/</guid>
      <description>Dynamodb localを使いローカルで開発時 SAM localのstart-apiやinvokeコマンドを使い、Lambda関数をローカルで実行する時は、
- Lambda関数がSAMのDockerコンテナ上で実行され - Dynamodb localが別のDockerコンテナ上で動く
そのため、Lambda関数がDynamodb localへアクセルできるように、 2つのDockerコンテナを同じネットワークに繋がせる必要があります。
対応方法は以下の通りです。
まずはDynamodb localのDockerセットアップ file: docker-compose.yml
services: dynamodb: container_name: dynamodb #重要：コンテナ名を指定 image: amazon/dynamodb-local networks: - aws_local_network #繋がるネットワークを指定 &amp;lt;省略&amp;gt; networks: aws_local_network: name: aws_local_network #重要：ネットワーク名を強制的に指定 そして、モデルのソースコードを以下のように修正
if os.environ.get(&amp;#39;AWS_SESSION_TOKEN&amp;#39;) is None: host = &amp;#34;http://dynamodb:8000&amp;#34; 　解説： AWS_SESSION_TOKEN 環境変数には、実際のAWS環境で実行する時にしか値がないので
ローカルで実行しているかどうなの判別に使えます。
また、http://dynamodb:8000のdynamodbはDynamodb localのコンテナ名です。
最後に、Lambda関数をローカルで実行する時 --docker-network aws_local_network を追加で指定
sam local start-api --docker-network aws_local_network
又は、sam local invoke HogeFunction -e event.json --docker-network aws_local_network</description>
    </item>
    
  </channel>
</rss>